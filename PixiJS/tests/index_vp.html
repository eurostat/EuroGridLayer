<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Test</title>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.5/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-viewport@4.3.3/dist/viewport.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<body>
  <script type="text/javascript">
    //see doc: http://pixijs.download/release/docs/index.html
    //https://github.com/davidfig/pixi-viewport
    //https://davidfig.github.io/pixi-viewport/jsdoc/


    //specs of the grid service
    const gridServiceBaseURL = "https://raw.githubusercontent.com/eurostat/EuroGridLayer/master/PixiJS/tests/csvTiles/assets/csv/tiles/pop_grid_2011_10km/"
    const res = 10000;
    const origin = { x: 0, y: 0 };
    const tileFrameLimits = { xMin: 0, xMax: 10, yMin: 0, yMax: 10 };


    //TODO dynamic zoom level selection?
    //z=0 when the screen resolution is equal to the grid resolution, that is when a pixel on the screen has a size equal to the resolution
    const z = 1;
    const tileSize = Math.pow(2, 8 - z);


    //the cache structure for the grid tiles
    //these are indexed by z>x>y
    //when a tile has been requested and was not found, a tag "none" is set.
    //when a http request has been sent to retrieve a tile but the response has not been received yet, a tag "loading" is set.
    const tileCache = {
      cache: {},
      //retrieve a tile from its position in the tile structure
      getTile: function (z, x, y) {
        if (!this.cache[z]) this.cache[z] = {};
        if (!this.cache[z][x]) this.cache[z][x] = {};
        return this.cache[z][x][y];
      },
      //add a tile to the cache, once received
      store: function (z, x, y, tile) {
        if (!this.cache[z]) this.cache[z] = {};
        if (!this.cache[z][x]) this.cache[z][x] = {};
        this.cache[z][x][y] = tile;
      }
    };

    let type = "WebGL";
    if (!PIXI.utils.isWebGLSupported()) type = "canvas";

    //create application and add it to page
    let app = new PIXI.Application({
      width: 1500,
      height: 600,
      antialias: true
    });
    document.body.appendChild(app.view);

    app.renderer.backgroundColor = 0x000000;


    // create viewport
    const viewport = new Viewport.Viewport({
      screenWidth: app.view.width,
      screenHeight: app.view.height,
      interaction: app.renderer.plugins.interaction
    });

    // add the viewport to the stage
    app.stage.addChild(viewport);

    //TODO try to use that to fix the y orientation at the source
    viewport.setTransform(0, 0, 1, -1, 0, 0, 0, 0, 0);

    // activate plugins
    viewport
      .drag()
      .pinch()
      .wheel({ percent: 10.0, smooth: 5 }) //TODO make it two
      //.decelerate()
      ;


    //value to color
    //TODO decompose into 'value to class' function and 'class to style'. Use d3 for that
    var valueToColor = function (value) {
      var t = value / 1400000;
      t = Math.pow(t, 0.2);
      if (t > 1) console.log(value);
      //see https://github.com/d3/d3-scale-chromatic
      return PIXI.utils.string2hex(d3.rgb(d3.interpolateCubehelixDefault(t)).formatHex());
    };


    //draw a tile
    drawTile = function (tile) {

      //use one graphics per tile
      let gr = new PIXI.Graphics();

      //move and scale the tile graphics to draw each cell as a 1 pixel size element in the tile coordinates
      var dx = origin.x + tile.x * tileSize * res;
      var dy = origin.y + tile.y * tileSize * res;
      gr.setTransform(dx, -dy, res, -res, 0, 0, 0, 0, 0);

      //draw the cells
      for (var j = 0; j < tile.cells.length; j++) {

        //get cell
        var cell = tile.cells[j];

        //get cell drawing style
        let fcol = valueToColor(cell.val);

        //draw the cell
        gr.beginFill(fcol);
        gr.drawRect(cell.x, cell.y, 1, 1);
        //TODO find why this does not work !
        //gr.drawRoundedRect(cell.x, -cell.y, 0.8, 0.8, 0.2);
        //gr.drawCircle(cell.x, -cell.y, 1);
        gr.endFill();
      }
      viewport.addChild(gr);
    };


    var refresh = function (clear) {
      if (clear)
        viewport.removeChildren();

      var bn = viewport.getVisibleBounds(),
        tileXMin = Math.floor((bn.x - origin.x) / (res * tileSize)),
        tileXMax = Math.floor((bn.x + bn.width - origin.x) / (res * tileSize)) + 1,
        tileYMax = Math.floor((-bn.y - origin.y) / (res * tileSize)) + 1,
        tileYMin = Math.floor((-bn.y - bn.height - origin.y) / (res * tileSize))
        ;
      tileXMin = Math.max(tileXMin, tileFrameLimits.xMin);
      tileXMax = Math.min(tileXMax, tileFrameLimits.xMax);
      tileYMin = Math.max(tileYMin, tileFrameLimits.yMin);
      tileYMax = Math.min(tileYMax, tileFrameLimits.yMax);

      for (var x = tileXMin; x <= tileXMax; x++)
        for (var y = tileYMin; y <= tileYMax; y++) {
          //check if tile exists in cache
          var tile = tileCache.getTile(z, x, y);
          //if there is no tile there or it is already loading, continue
          if (tile === "none" || tile === "loading") continue;
          //if the tile was already loaded into the cach, draw it
          if (tile) {
            drawTile(tile);
            continue;
          }
          //get the tile
          (function (x, y, z) {
            //tag tile as being loaded in the cache
            tileCache.store(z, x, y, "loading");
            d3.csv(gridServiceBaseURL + z + "/" + x + "/" + y + ".csv")
              .row(function (d) { return { x: d.x, y: d.y, val: +d.val }; })
              .get(function (error, cells) {
                if (!cells) {
                  //no tile was found: keep that info in the cache to avoid asking again
                  tileCache.store(z, x, y, "none");
                  return;
                }
                //make tile
                var tile = { x: x, y: y, cells: cells };
                //store tile in cache
                tileCache.store(z, x, y, tile);
                //draw tile
                drawTile(tile);
              });
          })(x, y, z);
        }


    };


    viewport.on("wheel", e => {
      //console.log(e);
      refresh(true);
    });

    viewport.on("moved-end", e => {
      //console.log(e);
      refresh(true);
    });

    viewport.on("clicked", e => {
      console.log(e);
      console.log(viewport.scaled);
      //console.log(tileCache);
      //refresh();
      //TODO retrieve and show cell value under the click
    });


    //interpretation of scaled factor: pixelSizeM = 1/scaled. a grid cell is represented as a single pixel when scaled = 1/res
    viewport.setZoom(0.001, true);
    viewport.moveCenter(4304777, -3064954);

    refresh();

  </script>
</body>

</html>