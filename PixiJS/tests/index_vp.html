<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Test</title>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.5/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-viewport@4.3.3/dist/viewport.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<body>
  <script type="text/javascript">
    //see doc: http://pixijs.download/release/docs/index.html
    //https://github.com/davidfig/pixi-viewport
    //https://davidfig.github.io/pixi-viewport/jsdoc/


    //TODO dynamic zoom level selection?
    //z=0 when the screen resolution is equal to the grid resolution, that is when a pixel on the screen has a size equal to the resolution
    const z = 1;
    const tileSize = Math.pow(2, 8 - z);
    const res = 10000;
    const origin = { x: 0, y: 0 };

    const tileCache = {
      cache: {},
      store: function (z, x, y, tile) {
        if (!this.cache[z]) this.cache[z] = {};
        if (!this.cache[z][x]) this.cache[z][x] = {};
        this.cache[z][x][y] = tile;
      },
      getTile: function (z, x, y) {
        if (!this.cache[z]) this.cache[z] = {};
        if (!this.cache[z][x]) this.cache[z][x] = {};
        return this.cache[z][x][y];
      }
    };

    let type = "WebGL";
    if (!PIXI.utils.isWebGLSupported()) type = "canvas";

    //create application and add it to page
    let app = new PIXI.Application({
      width: 1200,
      height: 500,
      antialias: true
    });
    document.body.appendChild(app.view);

    app.renderer.backgroundColor = 0x333333;

    // create viewport
    const viewport = new Viewport.Viewport({
      screenWidth: 1200,
      screenHeight: 500,
      interaction: app.renderer.plugins.interaction
    });

    // add the viewport to the stage
    app.stage.addChild(viewport);

    // activate plugins
    viewport
      .drag()
      .pinch()
      .wheel({ percent: 10.0, smooth: 5 }) //TODO make it two
      //.decelerate()
      ;


    //value to color
    var valueToColor = function (value) {
      var t = value / 1400000;
      t = Math.pow(t, 0.2);
      if (t > 1) console.log(value);
      //see https://github.com/d3/d3-scale-chromatic
      return PIXI.utils.string2hex(d3.rgb(d3.interpolateCubehelixDefault(t)).formatHex());
    };

    drawTile = function (tile) {
      let gr = new PIXI.Graphics();
      for (var j = 0; j < tile.cells.length; j++) {
        var cell = tile.cells[j];
        //draw cell
        gr.x = origin.x + tile.x * tileSize * res;
        gr.y = origin.y + tile.y * tileSize * res;
        gr.y = -gr.y;
        //TODO use something like: gr.scale = res;
        gr.beginFill(valueToColor(cell.val));
        gr.drawRect(res * cell.x, -res * cell.y, res, res);
        //test drawRoundedRect ?
        gr.endFill();
      }
      viewport.addChild(gr);
    };


    var refresh = function (clear) {
      if (clear)
        viewport.removeChildren();

      var bn = viewport.getVisibleBounds(),
        tileXMin = Math.floor((bn.x - origin.x) / (res * tileSize)),
        tileXMax = Math.floor((bn.x + bn.width - origin.x) / (res * tileSize)) + 1,
        tileYMax = Math.floor((-bn.y - origin.y) / (res * tileSize)) + 1,
        tileYMin = Math.floor((-bn.y - bn.height - origin.y) / (res * tileSize))
        ;

      for (var x = tileXMin; x <= tileXMax; x++)
        for (var y = tileYMin; y <= tileYMax; y++) {
          //check if tile exists in cache
          var tile = tileCache.getTile(z, x, y);
          //if there is no tile there or it is already loading, continue
          if (tile === "none" || tile === "loading") continue;
          //if the tile was already loaded into the cach, draw it
          if (tile) {
            drawTile(tile);
            continue;
          }
          //get the tile
          (function (x, y, z) {
            //tag tile as being loaded in the cache
            tileCache.store(z, x, y, "loading");
            d3.csv("https://raw.githubusercontent.com/eurostat/EuroGridLayer/master/PixiJS/tests/csvTiles/assets/csv/tiles/pop_grid_2011_10km/" + z + "/" + x + "/" + y + ".csv")
              .row(function (d) { return { x: d.x, y: d.y, val: +d.val }; })
              .get(function (error, cells) {
                if (!cells) {
                  //no tile was found: keep that info in the cache to avoid asking again
                  tileCache.store(z, x, y, "none");
                  return;
                }
                //make tile
                var tile = { x: x, y: y, cells: cells };
                //store tile in cache
                tileCache.store(z, x, y, tile);
                //draw tile
                drawTile(tile);
              });
          })(x, y, z);
        }


    };


    viewport.on("wheel", e => {
      //console.log(e);
      refresh(true);
    });

    viewport.on("moved-end", e => {
      //console.log(e);
      refresh(true);
    });

    viewport.on("clicked", e => {
      //console.log(e);
    console.log(viewport.scaled);
    //console.log(tileCache);
      //refresh();
    });


    //interpretation of scaled factor: pixelSizeM = 1/scaled. a grid cell is represented as a single pixel when scaled = 1/res
    viewport.setZoom(0.001, true);
    viewport.moveCenter(4304777, -3064954);

    refresh();

  </script>
</body>

</html>