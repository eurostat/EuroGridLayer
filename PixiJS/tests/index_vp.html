<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Test</title>
</head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.5/pixi.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pixi-viewport@4.3.3/dist/viewport.min.js"></script>

<body>
  <script type="text/javascript">
    //see doc: http://pixijs.download/release/docs/index.html
    //https://github.com/davidfig/pixi-viewport
    //https://davidfig.github.io/pixi-viewport/jsdoc/

    const tileSize = 64;
    const resolution = 10000;
    const origin = { x: 0, y: 0 };

    console.log("Build application...");

    let type = "WebGL";
    if (!PIXI.utils.isWebGLSupported()) type = "canvas";

    //create application and add it to page
    let app = new PIXI.Application({
      width: 1200,
      height: 500,
      antialias: true
    });
    document.body.appendChild(app.view);

    app.renderer.backgroundColor = 0x061639;

    // create viewport
    const viewport = new Viewport.Viewport({
      screenWidth: 1200,
      screenHeight: 500,
      //worldWidth: 2000000,
      //worldHeight: 6000000, //TODO use top/bottom/right/left instead ?
      interaction: app.renderer.plugins.interaction
    });

    // add the viewport to the stage
    app.stage.addChild(viewport);

    // activate plugins
    viewport
      .drag()
      .pinch()
      .wheel({percent:2.0, smooth:5})
      //.decelerate()
      ;

    console.log("Draw...");




    //value to color
    var valueToColor = function (value) {
      if (value > 1000) return 0xff0f00; //red
      if (value > 500) return 0xffce08; //orange
      if (value > 100) return 0xebff0a; //yellow
      if (value > 0) return 0x55e238; //green
      return 0xffffff; //white
    };

    drawTile = function (tile) {
      let gr = new PIXI.Graphics();
      for (var j = 0; j < tile.cells.length; j++) {
        var cell = tile.cells[j];
        //draw cell
        gr.x = origin.x + tile.x * tileSize * resolution;
        gr.y = origin.y + tile.y * tileSize * resolution;
        gr.y = gr.y;
        //TODO fix that:
        //gr.scale = resolution;
        gr.beginFill(valueToColor(cell.val));
        gr.drawRect(
          resolution * cell.x,
          resolution * cell.y,
          resolution,
          resolution
        );
        gr.endFill();
      }
      viewport.addChild(gr);
    };





    //interpretation of scaled factor:
    //pixelSizeM = 1/scaled
    //a grid cell is represented as a single pixel when scaled = 1/resolution
    //viewport.scaled = 0.0001;
    viewport.setZoom(0.0001, true);
    viewport.moveCenter(2304777, 1764954);
    //console.log(viewport.scaled);


    viewport.on("wheel", e => {
      console.log(e);
      //TODO
    });

    viewport.on("clicked", e => {
      console.log(e.world);
      //TODO show stat value
    });
    //TODO no event for mouse move ?


    //console.log(viewport.getVisibleBounds());
    //use that to find the tiles to load and show
    //use that to load tiles:
    //load an image and run the `setup` function when it's done
    //PIXI.loader
    //    .add("images/cat.png")
    //    .load(setup);

    //TODO find a way to invert y axis... but how?











    //xmlhttp request for csv files
    const getCSV = (url, callback) => {
      var xmlhttp = new XMLHttpRequest();
      xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {
          try {
            var data = xmlhttp.responseText;
          } catch (err) {
            /* console.log(err.message + " in " + xmlhttp.responseText); */
            return;
          }
          callback(data);
        }
      };
      xmlhttp.open("GET", url, true);
      xmlhttp.send();
    };

    // parseCSV and convert to array
    const parseCSV = (str) => {
      var arr = [];
      var quote = false; // true means we're inside a quoted field

      // iterate over each character, keep track of current row and column (of the returned array)
      for (var row = 0, col = 0, c = 0; c < str.length; c++) {
        var cc = str[c],
          nc = str[c + 1]; // current character, next character
        arr[row] = arr[row] || []; // create a new row if necessary
        arr[row][col] = arr[row][col] || ""; // create a new column (start with empty string) if necessary

        // If the current character is a quotation mark, and we're inside a
        // quoted field, and the next character is also a quotation mark,
        // add a quotation mark to the current column and skip the next character
        if (cc == '"' && quote && nc == '"') {
          arr[row][col] += cc;
          ++c;
          continue;
        }

        // If it's just one quotation mark, begin/end quoted field
        if (cc == '"') {
          quote = !quote;
          continue;
        }

        // If it's a comma and we're not in a quoted field, move on to the next column
        if (cc == "," || (cc == ";" && !quote)) {
          ++col;
          continue;
        }

        // If it's a newline (CRLF) and we're not in a quoted field, skip the next character
        // and move on to the next row and move to column 0 of that new row
        if (cc == "\r" && nc == "\n" && !quote) {
          ++row;
          col = 0;
          ++c;
          continue;
        }

        // If it's a newline (LF or CR) and we're not in a quoted field,
        // move on to the next row and move to column 0 of that new row
        if (cc == "\n" && !quote) {
          ++row;
          col = 0;
          continue;
        }
        if (cc == "\r" && !quote) {
          ++row;
          col = 0;
          continue;
        }

        // Otherwise, append the current character to the current column
        arr[row][col] += cc;
      }
      return arr;
    };






    for (var x = 0; x < 10; x++)
      for (var y = 0; y < 10; y++) {
        (function (x,y) {
          var testCSV = "https://raw.githubusercontent.com/eurostat/EuroGridLayer/master/PixiJS/tests/csvTiles/assets/csv/tiles/pop_grid_2011_10km/2/" + x + "/" + y + ".csv";
          getCSV(testCSV, data => {
            data = parseCSV(data);
            //build
            var tile = { x: x, y: y, cells: [] };
            for (var i = 1; i < data.length; i++) {
              var line = data[i];
              tile.cells.push({ x: line[0], y: line[1], val: line[2] });
            }
            //draw tile
            drawTile(tile);
          });
        })(x,y);
      }



  </script>
</body>

</html>
